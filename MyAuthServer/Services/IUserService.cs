using MyAuthServer.RequestStructures;
using MyAuthServer.SQL;
using Serilog;
using System.Security.Cryptography;

namespace MyAuthServer.Services
{
	/// <summary>
	/// Provides various user and user account related operations.
	/// </summary>
	public interface IUserService
	{
		/// <summary>
		/// Changes the password of the currently logged in user.
		/// </summary>
		/// <param name="userId">The ID of the user.</param>
		/// <param name="request">The request form provided by the client.</param>
		/// <param name="ip">The current remote IP address.</param>
		/// <returns>Information about and generated by the operation.</returns>
		Task<UserPasswordChangeModel> ChangeUserPassword(int userId, ChangePasswordRequest request, string ip);

		/// <summary>
		/// Checks if a username already belongs to an account.
		/// </summary>
		/// <param name="username">The username to check.</param>
		Task<bool> IsUsernameTakenAsync(string username);

		/// <summary>
		/// Attempts to log in the current device with the provided credentials.
		/// </summary>
		/// <param name="request">The request form provided by the client.</param>
		/// <returns>Information about and generated by the operation.</returns>
		Task<UserLoginModel> LoginUserAsync(CustomLoginRequest request);

		/// <summary>
		/// Attempts to log the current user out.
		/// </summary>
		/// <param name="request">The request form provided by the client.</param>
		Task LogoutAsync(BasicRequest request);

		/// <summary>
		/// Attempts to register a user.
		/// </summary>
		/// <param name="request">The request form provided by the client.</param>
		Task RegisterUserAsync(CustomLoginRequest request);
	}

	/// <summary>
	/// Main implementation of <see cref="IUserService"/>
	/// </summary>
	/// <param name="databaseServiceFactory"></param>
	public class UserService(IDatabaseServiceFactory databaseServiceFactory) : IUserService
	{
		private readonly IDatabaseServiceFactory _databaseFactory = databaseServiceFactory;

		private static readonly string changePasswordSQL1 = SQLQueryBuilder.Begin(SQLKeywords.SELECT).From("logins").Where("id", SQLKeywords.EQUALS).BuildAndClear();

		private static readonly string changePasswordSQL2 = SQLQueryBuilder.Begin(SQLKeywords.UPDATE, "logins").Set("password").AdditionalSets("salt").Where("username", SQLKeywords.EQUALS).And("id", SQLKeywords.EQUALS).BuildAndClear();

		public async Task<UserPasswordChangeModel> ChangeUserPassword(int userId, ChangePasswordRequest request, string ip)
		{
			var list = await _databaseFactory.GetDatabaseService("loginInfoDatabase").ExecuteReaderAsync(changePasswordSQL1, reader =>
			{
				List<object> result = [];
				result.Add(reader.GetInt32(0));
				result.Add(reader.GetString(1));
				result.Add(reader.GetString(2));
				result.Add(reader.GetString(3));
				return result;
			}, [("@id", userId)]);

			if (list.Count == 0)
				return new(false, "The user you are trying to change the password for does not exist");

			var id = (int)list[0];
			string username = (string)list[1];
			var currentPasswordHash = (string)list[2];
			var currentSalt = (string)list[3];

			// Check that the passwords don't match.
			var usableSalt = Convert.FromBase64String(currentSalt);
			var suppliedPasswordHash = Convert.ToBase64String(HashPassword(request.Password, usableSalt));

			if (currentPasswordHash == suppliedPasswordHash)
				return new(false, "Your new password cannot be the same as your current password");

			var newSalt = GenerateSalt();
			var newPasswordHash = HashPassword(request.Password, newSalt);
			var stringSalt = Convert.ToBase64String(newSalt);
			var stringPassword = Convert.ToBase64String(newPasswordHash);

			await _databaseFactory.GetDatabaseService("loginInfoDatabase").ExecuteNonQueryAsync(changePasswordSQL2, [("@password", stringPassword), ("@salt", stringSalt),("@username", username), ("@id", id)]);
			Log.Information($"User {username} has had their password changed from IP: {ip}.");
			return new(true, string.Empty);
		}

		private static readonly string isUsernameRegisteredSQL = SQLQueryBuilder.Begin(SQLKeywords.SELECT).From("logins").Where("username", SQLKeywords.EQUALS).BuildAndClear();

		public async Task<bool> IsUsernameTakenAsync(string username)
		{
			var database = _databaseFactory.GetDatabaseService("loginInfoDatabase");
			bool result = await database.ExecuteReaderHasRowsAsync(isUsernameRegisteredSQL, [("@username", username)]);
			return result;
		}

		private static readonly string verifyCredentialsSQL = SQLQueryBuilder.Begin(SQLKeywords.SELECT).From("logins").Where("username", SQLKeywords.EQUALS).BuildAndClear();

		public async Task<UserLoginModel> LoginUserAsync(CustomLoginRequest request)
		{
			var list = await _databaseFactory.GetDatabaseService("loginInfoDatabase").ExecuteReaderAsync(verifyCredentialsSQL, reader =>
			{
				List<object> result = [];
				result.Add(reader.GetInt32(0));
				result.Add(reader.GetString(1));
				result.Add(reader.GetString(2));
				result.Add(reader.GetString(3));
				return result;
			}, [("@username", request.Username)]);


			var id = (int)list[0];
			var username = (string)list[1];
			var passwordHash = (string)list[2];
			var salt = (string)list[3];

			// Hash the given password, using the existing salt.
			var usableSalt = Convert.FromBase64String(salt);
			var suppliedPasswordHash = Convert.ToBase64String(HashPassword(request.Password, usableSalt));

			if (username == request.Username && passwordHash == suppliedPasswordHash)
			{
				var token = Guid.NewGuid().ToString();
				
				return new(true, token, id);
			}
			return new(false, string.Empty, 0);
		}

		private static readonly string registerUserSQL = SQLQueryBuilder.Begin(SQLKeywords.INSERT).IntoValues("logins", "username", "password", "salt").BuildAndClear();

		public async Task RegisterUserAsync(CustomLoginRequest request)
		{
			var salt = GenerateSalt();
			var password = HashPassword(request.Password, salt);
			await _databaseFactory.GetDatabaseService("loginInfoDatabase").ExecuteNonQueryAsync(registerUserSQL, [("@username", request.Username), ("@password", Convert.ToBase64String(password)), ("@salt", Convert.ToBase64String(salt))]);
		}

		private static readonly string removeSessionSQL = SQLQueryBuilder.Begin(SQLKeywords.DELETE).From("sessionTokens").Where("token", SQLKeywords.EQUALS).And("deviceId", SQLKeywords.EQUALS).BuildAndClear();

		public async Task LogoutAsync(BasicRequest request)
		{
			await _databaseFactory.GetDatabaseService("sessionTokenDatabase").ExecuteNonQueryAsync(removeSessionSQL, [("@token", request.SessionToken), ("@deviceId", request.DeviceId)]);
		}

		private static byte[] GenerateSalt()
		{
			byte[] salt = new byte[32];
			using var rng = RandomNumberGenerator.Create();
			rng.GetBytes(salt);
			return salt;
		}

		private static byte[] HashPassword(string password, byte[] salt, int iterations = 10000)
		{
			using var pbkdf2 = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA512);
			return pbkdf2.GetBytes(32);
		}
	}
}
